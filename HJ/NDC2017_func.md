# 더 좋은 코드를 위한 함수형 프로그래밍 (NDC2017)

## 순수함수 (Pure functions)   
- 함수의 결과값이 오직 입력 인자 값들에 의해서만 결정
- 특정 입력 값에 대해서 결과값이 결정적으로 대응되는 함수
- 부작용(side effects)이 없는 함수
- 시간에 의존, 전역 변수에 의존하는 것은 비순수함수 - 글로벌, 멤버 변수의 의존도를 줄이는 것이 좋다
- 부작용
    - 상태에 영향을 받거나 변화를 주는 모든 동작
    - 화면출력
    - 소켓통신
    - 디스크 I/O
    - 예외 catch
    - 현재 시각 읽기
    - 난수 발생
- 참조 투명성 (Referential transparency)
    - 어떤 표현식을 그 표현식의 결과값으로 교체해도 전체 프로그램의 실행 결과에 영향을 주지 않는 성질
    - 최적화 방법
        - Memoization
        - Lazy evalution (지연 연산)   
        결과값이 필요할 때에 계산을 진행
- 레퍼런스 인자보다는 값을 리턴하도록 하고 여러 개의 값을 리턴할 때는 tuple 사용

## 불변성 (Immutability)
- 자연의 예로 DNA가 있다 → 새로운 다음 세대를 생성할 때만 변할 수 있다
- 불변객체의 특징
    - 내용의 변경은 새로운 객체를 생성할 때만 가능
    - 생성, 테스트, 사용법이 단순, 쉬움
    - read-only로 thread-safe
    - 내용이 변하지 않아 이름을 알면 같은 값을 가짐을 알 수 있어 쉬운 캐쉬
    - 객체를 변경하지 않는 멤버함수들은 const로
    - 코딩 스타일
        - temporal coupling가 줄어든다
            - 불변객체는 생성할 때 모든 정보를 제공해야해서 (인자로 초기화) 유효한 동작만을 할 수 있다
        - Identity mutability problem이 없다
            - setter로 정체성을 바꿀 수 있는데 불변객체는 이를 방지할 수 있다

## 고차함수
- 함수의 인자로 한 개 이상의 함수를 넘겨 받거나, 함수의 결과값으로 다른 함수를 돌려주는 함수
- C++에서는 #include <algorithm> → funtioncal이 가능
- FP의 기본 초식 3총사   
    ##### 언어는 C++ ( python )
    - std::transform (=map)
    - std::remove_if / std::copy_if (=filter)
    - std::accumulate (=reduce) 
- 고차 함수를 사용해 코드를 간결하게! → 간결한 코드 -> 가독성 -> 적은 버그
-로직의 구현 부분과 사용 부분을 완전히 격리시킬 수 있다
- 합성 가능하게 만들어 재활용
    - 간단한 것들을 모아 복잡한 것을 하자 (Unix 철학)
    - 타입도 코드도 합성 가능

## 타입 시스템
- 타입의 활용
    - 메모리상에 저장된 데이터가 쓰일 방법을 정의
    - 가능한 빠른 단계에서 오류 발견
    - 코드의 의미 함축성 증가
    - 코드 작성중의 힌트
    - 로직 설계의 도구
    - 지원하지 않는 동작은 표현 자체가 불가능하게
    - 합성 동작의 연결을 위한 접착제
- 타입을 최대한 사용해 안전한 코드를 만들 수 있다
- 타입의 Cardinality 파악(계산)해보기
- 표현조차 불가능한 코드를 만들어 안전하게

## 모나드 (Monad)
- 합성을 어떻게든 해보자는 느낌
- 더 공부해야 될듯..  
[Monad in scala](https://wingnim.tistory.com/106)

<br/>
<hr/>

## Reference
[NDC2017](http://ndcreplay.nexon.com/NDC2017/sessions/NDC2017_0025.html)  
