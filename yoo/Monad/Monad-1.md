# 모나드와 함수형 아키텍처

## 1. 시작하기
### 1-1. 타입
보통 코드를 작성할 때는 string, int, float, double 등과 같은 `원시 타입(Primitive type)` 이 외에도 enum, struct, class 등을 사용하여 우리가 원하는 타입을 추상화를 통해 만들 수 있으며 이렇게 만들어진` 타입을 집합으로 생각`한다.

```
Boolean = {False, True}
Int = {...,-2,-1,0,1,2,...}
String = {"a", "aa", "b", ...}
```

### 1-1. 프로그래밍 패러다임
- 우리는 큰 문제를 해결하기 위해 작은 문제로 나눠서 풀 수 있다.
- 객체지향에선 프로그램을 모듈화하여 데이터와 로직을 가진 여러 클래스가 서로 관계를 맺으면서 문제를 해결하고 프로그램을 구성


### 모나드
#### 1. 닫힘과 열림
집합 A에 대해서 이항연산을 수행할 때 연산 결과가 같은 집합 A의 원소이면 해당 이항연산은 집합 A에 닫혀 있다고 한다. 자연수 집합 N에서 +연산은 자연수 집합에 닫혀 있다.
> 1 + 2 = 3

집합 A에 대하여 이항연산을 수행할 때 연산결과가 같은 집합 A의 원소가 아니면 해당 이항연산은 집합 A에 열려있다고 한다. 자연수 집합 N에서 -연산은 자연수 집합에 열려 있다.
> 1 - 1 = 0

0은 자연수 집합에 포함되어 있지 않기 때문에 자연수 집합 N에서 -연산은 열려 있다? (요즘은 0도 자연수에 포함시킴)

<img src="https://teamdable.github.io/techblog/assets/images/moand-and-functional-architecture/category.png">

이 그림은 카테고리 이론(이하 범주론)을 설명하는 그림이다.

그림에서 A, B, C 를 연결하는 화살표에서 `f:A→B` 가 있고 `g:B→C` 가 존재하면 반드시 `g∘f:A→C` 가 존재한다는 것이 카테고리 이론입니다.

시간이 지날수록 컴퓨터 프로그램에 신규 기능을 추가하면 프로그램의 덩치가 커지는데 이러한 함수 합성을 적용하면 큰 문제 없이 확장할 수 있다.

#### 2. 순수함수와 사이드 이펙트
파일이름을 받아서 파일을 반환하는 함수가 있다고 가정한다.
```
f: FileName -> File
```
내부에서 사이드 이펙트가 발생하지 않고 항상 File을 반영한다면 함수 f는 순수함수가 된다.

하지만 FileName에 해당하는 파일이 없다면 Error가 발생하고 Java에선 Exceptionㅇ을 도입해서 예외처리를 하는데 이는 순수함수의 성질을 깨는 것이다.

순수함수성이 깨진다는 것은 독립된 함수일 때 결과값 집합 이외의 집합값을 반환해서 사이드이펙트가 발생하여 함수 합성을 더 이상 할 수 없다.

#### 3. 모나드란?
그럼 만약 결과값 집합과 오류값 집합을 하나의 집합으로 만들면 어떻게 될까?

<img src="https://blog.burt.pe.kr/series/monad-and-functional-architecture-part-3/images/monad.png">

모나드는 함수 내부에서 발생할 수 있는 사이드이펙트를 결과 집합과 함께 포함하는 타입이다. 함수 실행결과를 항상 모나드로 반환하여 순수함수 성질을 잃지 않게 하는 것이다.

정확히는 원시타입(boolean, int, float, double)과 참조타입(배열, 클래스)을 구체타입이라고 할 때 우리는 구체타입을 사용하여 함수의 인자와 결과값을 표현했는데
이 구체타입을 한 번 더 추상화한 것이 모나드이다.

> 어떤 타입 M에 대해 아래의 두 함수, pure과 compose가 존재할 때, M은 모나드입니다.

```
f: FileName -> Monad[File, Error]
```

함수의 결과값에 모나드를 적용하면 내부에선 어떤 사이드이펙트가 발생하던 그 함수 자체는 순수함수로 만들 수 있다.

이를 응용하면 사이드이펙트가 아닌 다른 집합을 포함하는 타입을 생각할 수 있는데 자주 쓰는 모나드 중 `Either`가 가장 대표적인 예로 `Either`모나드는 `Left`와 `Right`를 가지고 있는 타입으로
`Either[Left, Right]`라고 정의할 수 있다.

모나드는 함수에 들어가고 반환되는 값을 한차례 추상화한 것이다. `f: int -> int`함수가 있을 때, 함수인자 또는 반환값을 추상화하는 것이다.

Java에서 원시타입인 int, double, boolean 등을 모아 class를 통해 추상화하듯이 생각할 수 있다.

Maybe 모나드는 `값이 있거나 없거나` 라는 의미를 담는다. 구체타입을 추상화하면서 의미를 동시에 담을 수 있게 되어 마치 사람이 생각하는 것처럼 함수를 작성할 수 있다.

하지만 지금까지 본 부분은 구조체나 클래스로도 정의할 수 있는데 여기서 모나드를 더욱 구분지어주는 특징이 하나 더 있는데 바로 합성을 통해 흐름을 만드는 것이다.

#### 4. 합성, 흐름
모나드를 통해 함수를 합성하기 위해서는 함수의 인자와 결과값이 모두 모나드로 되어 있어야 한다.

```
f: Monad -> Monad
g: Monad -> Monad
h: Monad -> Monad
h ∘ g ∘ f: Monad -> Monad -> Monad
```




#### flatMap

```scala
val nestedNumbers = List(List(1, 2), List(3, 4))
nestedNumbers.flatMap(x => x.map(_ * 2))

res0: List[Int] = List(2, 4, 6, 8)
```
flatMap이란 하나의 리스트로 합쳐준다는 것에 주의하면 된다. 그냥 map을 적용했다면 List(2,4) List(6,8)이 나왔을 것이다.